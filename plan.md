# Plan Realizacji: Generator Projekt√≥w Blender VSE

## üìÖ Harmonogram Og√≥lny

**Metodologia**: TDD (Test-Driven Development)  
**Podej≈õcie**: Iteracyjne z testowaniem po ka≈ºdej fazie

## üèóÔ∏è Faza 1: Przygotowanie Infrastruktury (1 dzie≈Ñ)

### Zadanie 1.1: Konfiguracja Blender Python API

#### Kroki:
1. **Sprawdzenie dostƒôpno≈õci bpy**
   ```bash
   # Test czy bpy jest dostƒôpne w systemie
   python -c "import bpy; print('Blender API available')"
   ```

2. **Wyb√≥r strategii integracji**
   - **Opcja**: Wywo≈Çanie zewnƒôtrzne Blender z skryptem
   
3. **Konfiguracja ≈õrodowiska**
   ```bash
   # sprawdzenie dostƒôpno≈õci blender w PATH
   which blender
   ```

#### Kryteria Akceptacji:
- [ ] Mo≈ºliwo≈õƒá importu/wywo≈Çania Blender API
- [ ] Test tworzenia pustego projektu .blend
- [ ] Dokumentacja wybranej strategii

### Zadanie 1.2: Struktura Modu≈Ç√≥w

#### Kroki:
1. **Utworzenie struktury plik√≥w**
   ```
   src/
   ‚îú‚îÄ‚îÄ core/
   ‚îÇ   ‚îú‚îÄ‚îÄ blender_project.py    # G≈Ç√≥wna logika VSE
   ‚îÇ   ‚îî‚îÄ‚îÄ audio_validator.py    # Walidacja i detekcja plik√≥w audio
   ‚îî‚îÄ‚îÄ cli/
       ‚îî‚îÄ‚îÄ blend_setup.py        # Interface CLI
   ```

2. **Podstawowe importy i szkielety klas**
   ```python
   # core/blender_project.py
   class BlenderProjectManager:
       def create_vse_project(self, recording_path: Path) -> Path:
           pass
   
   # core/audio_validator.py  
   class AudioValidator:
       def detect_main_audio(self, extracted_dir: Path, specified_audio: str = None) -> Path:
           pass
   ```

#### Kryteria Akceptacji:
- [ ] Struktura plik√≥w utworzona
- [ ] Podstawowe klasy zdefiniowane
- [ ] Importy dzia≈ÇajƒÖ bez b≈Çƒôd√≥w

### Zadanie 1.3: Konfiguracja Test√≥w

#### Kroki:
1. **Utworzenie plik√≥w testowych**
   ```
   tests/
   ‚îú‚îÄ‚îÄ test_blender_project.py
   ‚îú‚îÄ‚îÄ test_audio_validator.py
   ‚îî‚îÄ‚îÄ test_blend_setup_cli.py
   ```

2. **Konfiguracja fixtures**
   ```python
   # tests/conftest.py
   @pytest.fixture
   def sample_recording_structure():
       # Struktura testowa z plikami
       pass
   ```

#### Kryteria Akceptacji:
- [ ] Pliki testowe utworzone
- [ ] Fixtures skonfigurowane
- [ ] `pytest` uruchamia siƒô bez b≈Çƒôd√≥w

## üîß Faza 2: Walidacja i Detekcja Plik√≥w Audio (1 dzie≈Ñ)

### Zadanie 2.1: Implementacja AudioValidator

#### Kroki:
1. **Test-driven development**
   ```python
   # tests/test_audio_validator.py
   def test_single_audio_file_detection():
       # Test gdy jest tylko jeden plik audio
       validator = AudioValidator()
       result = validator.detect_main_audio(extracted_dir)
       assert result is not None
   
   def test_multiple_audio_files_error():
       # Test gdy jest wiƒôcej ni≈º jeden plik audio
       validator = AudioValidator()
       with pytest.raises(MultipleAudioFilesError):
           validator.detect_main_audio(extracted_dir)
   ```

2. **Implementacja walidatora**
   ```python
   # core/audio_validator.py
   class AudioValidator:
       def detect_main_audio(self, extracted_dir: Path, specified_audio: str = None) -> Path:
           """Wykrywa g≈Ç√≥wny plik audio lub zg≈Çasza b≈ÇƒÖd"""
           audio_files = self.find_audio_files(extracted_dir)
           
           if specified_audio:
               return self.validate_specified_audio(extracted_dir, specified_audio)
           
           if len(audio_files) == 0:
               raise NoAudioFileError("Brak plik√≥w audio w katalogu extracted/")
           elif len(audio_files) > 1:
               raise MultipleAudioFilesError(f"Znaleziono {len(audio_files)} plik√≥w audio. U≈ºyj --main-audio aby wskazaƒá w≈Ça≈õciwy.")
           
           return audio_files[0]
   ```

3. **Obs≈Çuga b≈Çƒôd√≥w**
   - Walidacja istnienia pliku audio
   - Obs≈Çuga przypadku wielu plik√≥w audio
   - Walidacja parametru --main-audio

#### Kryteria Akceptacji:
- [ ] Testy przechodzƒÖ (TDD)
- [ ] Detekcja pojedynczego pliku audio dzia≈Ça
- [ ] B≈ÇƒÖd przy wielu plikach audio
- [ ] Obs≈Çuga parametru --main-audio
- [ ] Dokumentacja metod

### Zadanie 2.2: Integracja z FileStructureManager

#### Kroki:
1. **Rozszerzenie FileStructureManager**
   ```python
   # core/file_structure.py
   @staticmethod
   def ensure_blender_dir(video_path: Path) -> Path:
       """Tworzy katalog blender/ w strukturze nagrania"""
       pass
   
   @staticmethod
   def find_audio_files(extracted_dir: Path) -> List[Path]:
       """Znajduje wszystkie pliki audio w katalogu extracted"""
       pass
   ```

2. **Testy integracji**
   ```python
   def test_blender_directory_creation():
       # Test tworzenia katalogu blender/
       pass
   
   def test_audio_files_detection():
       # Test znajdowania plik√≥w audio
       pass
   ```

#### Kryteria Akceptacji:
- [ ] Katalog `blender/` jest tworzony automatycznie
- [ ] Funkcja znajdowania plik√≥w audio
- [ ] Integracja z istniejƒÖcƒÖ strukturƒÖ
- [ ] Testy przechodzƒÖ

## üé¨ Faza 3: Tworzenie Projektu Blender VSE (2 dni)

### Zadanie 3.1: Podstawowa Konfiguracja Blender

#### Kroki:
1. **Szkielet BlenderProjectManager**
   ```python
   # core/blender_project.py
   class BlenderProjectManager:
       def __init__(self, blender_executable: str = "blender"):
           self.blender_executable = blender_executable
       
       def create_vse_project(self, recording_path: Path) -> Path:
           # 1. Przygotuj skrypt Blender
           # 2. Wywo≈Çaj blender --background --python script.py
           # 3. Zwr√≥ƒá ≈õcie≈ºkƒô do .blend
           pass
   ```

2. **Skrypt Blender (template)**
   ```python
   # templates/vse_setup_template.py
   import bpy
   
   # Czyszczenie sceny
   bpy.ops.wm.read_factory_settings(use_empty=True)
   
   # Konfiguracja VSE
   bpy.context.scene.sequence_editor_create()
   
   # Parametry renderingu
   bpy.context.scene.render.resolution_x = 1280
   bpy.context.scene.render.resolution_y = 720
   bpy.context.scene.render.fps = 30
   ```

3. **Testy podstawowe**
   ```python
   def test_create_empty_blend_project():
       manager = BlenderProjectManager()
       project_path = manager.create_vse_project(sample_recording_path)
       assert project_path.exists()
       assert project_path.suffix == '.blend'
   ```

#### Kryteria Akceptacji:
- [ ] Tworzenie pustego projektu .blend
- [ ] Konfiguracja VSE
- [ ] Podstawowe parametry renderingu
- [ ] Testy przechodzƒÖ

### Zadanie 3.2: Dodawanie ≈öcie≈ºek VSE

#### Kroki:
1. **Implementacja dodawania ≈õcie≈ºek**
   ```python
   def add_video_strips(self, video_files: List[Path], start_frame: int = 1):
       """Dodaje ≈õcie≈ºki wideo do VSE"""
       for i, video_file in enumerate(video_files):
           channel = i + 1
           # bpy.ops.sequencer.movie_strip_add(...)
   
   def add_main_audio_strip(self, audio_file: Path, start_frame: int = 1):
       """Dodaje g≈Ç√≥wnƒÖ ≈õcie≈ºkƒô audio do VSE na kanale 1"""
       # bpy.ops.sequencer.sound_strip_add(...)
   ```

2. **Logika organizacji kana≈Ç√≥w**
   - Video: kana≈Çy 1, 2, 3...
   - Audio: tylko g≈Ç√≥wny audio na kanale 1

3. **Testy z rzeczywistymi plikami**
   ```python
   def test_add_multiple_video_strips():
       # Test dodawania wielu ≈õcie≈ºek wideo
       pass
   
   def test_add_main_audio_strip():
       # Test dodawania g≈Ç√≥wnej ≈õcie≈ºki audio
       pass
   ```

#### Kryteria Akceptacji:
- [ ] Dodawanie ≈õcie≈ºek wideo dzia≈Ça
- [ ] Dodawanie g≈Ç√≥wnej ≈õcie≈ºki audio dzia≈Ça
- [ ] Prawid≈Çowa organizacja kana≈Ç√≥w
- [ ] Synchronizacja od frame 1
- [ ] Testy przechodzƒÖ

### Zadanie 3.3: Konfiguracja Renderingu

#### Kroki:
1. **Implementacja ustawie≈Ñ renderingu**
   ```python
   def configure_render_settings(self, output_path: Path, fps: int = 30):
       """Konfiguruje parametry renderingu"""
       # Rozdzielczo≈õƒá 720p
       bpy.context.scene.render.resolution_x = 1280
       bpy.context.scene.render.resolution_y = 720
       
       # Format MP4
       bpy.context.scene.render.image_settings.file_format = 'FFMPEG'
       bpy.context.scene.render.ffmpeg.format = 'MPEG4'
       bpy.context.scene.render.ffmpeg.codec = 'H264'
       
       # ≈öcie≈ºka wyj≈õciowa
       bpy.context.scene.render.filepath = str(output_path)
   ```

2. **Testy konfiguracji**
   ```python
   def test_render_settings_configuration():
       # Test ustawie≈Ñ renderingu
       pass
   ```

#### Kryteria Akceptacji:
- [ ] Rozdzielczo≈õƒá 1280x720
- [ ] Format MP4 (H.264)
- [ ] ≈öcie≈ºka wyj≈õciowa ustawiona
- [ ] FPS z metadanych
- [ ] Testy przechodzƒÖ

## üñ•Ô∏è Faza 4: Interface CLI (1 dzie≈Ñ)

### Zadanie 4.1: Implementacja CLI

#### Kroki:
1. **Parsowanie argument√≥w**
   ```python
   # cli/blend_setup.py
   import argparse
   
   def parse_args():
       parser = argparse.ArgumentParser(
           description='Tworzy projekt Blender VSE z nagrania OBS'
       )
       parser.add_argument('recording_dir', help='Katalog nagrania')
       parser.add_argument('--verbose', '-v', action='store_true')
       parser.add_argument('--force', '-f', action='store_true')
       parser.add_argument('--main-audio', help='Nazwa g≈Ç√≥wnego pliku audio')
       return parser.parse_args()
   ```

2. **G≈Ç√≥wna logika CLI**
   ```python
   def main():
       args = parse_args()
       
       # Walidacja katalogu
       recording_path = Path(args.recording_dir)
       if not recording_path.exists():
           print(f"B≈ÇƒÖd: Katalog {recording_path} nie istnieje")
           return 1
       
       # Tworzenie projektu
       manager = BlenderProjectManager()
       project_path = manager.create_vse_project(recording_path)
       
       print(f"Projekt utworzony: {project_path}")
       return 0
   ```

3. **Testy CLI**
   ```python
   def test_cli_basic_usage():
       # Test podstawowego u≈ºycia CLI
       pass
   
   def test_cli_invalid_directory():
       # Test obs≈Çugi b≈Çƒôd√≥w
       pass
   ```

#### Kryteria Akceptacji:
- [ ] Parsowanie argument√≥w dzia≈Ça
- [ ] Walidacja katalog√≥w
- [ ] Obs≈Çuga b≈Çƒôd√≥w
- [ ] Verbose mode
- [ ] Testy przechodzƒÖ

### Zadanie 4.2: Integracja Wszystkich Komponent√≥w

#### Kroki:
1. **Workflow integracji**
   ```python
   def create_vse_project(self, recording_path: Path, main_audio_name: str = None) -> Path:
       # 1. Walidacja struktury
       structure = FileStructureManager.find_recording_structure(recording_path)
       
       # 2. Detekcja g≈Ç√≥wnego audio
       audio_validator = AudioValidator()
       main_audio = audio_validator.detect_main_audio(structure.extracted_dir, main_audio_name)
       
       # 3. Znajd≈∫ wyekstraktowane pliki wideo
       video_files = self.find_video_files(structure.extracted_dir)
       
       # 4. Utw√≥rz projekt Blender
       blend_path = self.create_blend_file(video_files, main_audio, ...)
       
       return blend_path
   ```

2. **Testy end-to-end**
   ```python
   def test_full_workflow():
       # Test pe≈Çnego workflow od katalogu do projektu
       pass
   ```

#### Kryteria Akceptacji:
- [ ] Pe≈Çny workflow dzia≈Ça
- [ ] Wszystkie komponenty zintegrowane
- [ ] Testy E2E przechodzƒÖ
- [ ] Obs≈Çuga b≈Çƒôd√≥w na ka≈ºdym etapie

## üß™ Faza 5: Testowanie i Optymalizacja (1 dzie≈Ñ)

### Zadanie 5.1: Testy Kompleksowe

#### Kroki:
1. **Testy z r√≥≈ºnymi scenariuszami**
   ```python
   def test_scenario_only_video_files():
       # Test gdy sƒÖ tylko pliki wideo
       pass
   
   def test_scenario_single_audio_file():
       # Test gdy jest tylko jeden plik audio
       pass
   
   def test_scenario_mixed_files():
       # Test mieszanych plik√≥w
       pass
   ```


3. **Testy edge cases**
   - Pusty katalog extracted/
   - Wiele plik√≥w audio bez parametru --main-audio
   - Uszkodzone pliki wideo/audio
   - BrakujƒÖce metadane

#### Kryteria Akceptacji:
- [ ] Wszystkie scenariusze testowe przechodzƒÖ
- [ ] Wydajno≈õƒá w akceptowalnych granicach
- [ ] Edge cases obs≈Çu≈ºone
- [ ] Pokrycie test√≥w > 90%

### Zadanie 5.2: Dokumentacja i Finalizacja
**Czas**: 2 godziny  
**Priorytet**: ≈öredni

#### Kroki:
1. **Aktualizacja README.md**
   - Dodanie sekcji o Blender VSE
   - Przyk≈Çady u≈ºycia
   - Wymagania systemowe

2. **Dokumentacja API**
   - Docstrings dla wszystkich metod
   - Przyk≈Çady kodu
   - Diagramy workflow

3. **Finalne testy**
   ```bash
   # Uruchomienie pe≈Çnego zestawu test√≥w
   uv run pytest --cov=src --cov-report=html
   
   # Test CLI
   uv run python -m cli.blend_setup ./test_recording --verbose
   ```

#### Kryteria Akceptacji:
- [ ] Dokumentacja zaktualizowana
- [ ] API udokumentowane
- [ ] Wszystkie testy przechodzƒÖ
- [ ] Gotowe do produkcji

## üìã Harmonogram Szczeg√≥≈Çowy


### Ryzyko 1: Z≈Ço≈ºono≈õƒá obs≈Çugi wielu plik√≥w audio
**Prawdopodobie≈Ñstwo**: ≈örednie  
**Wp≈Çyw**: ≈öredni  
**Mitigacja**: Jasne komunikaty b≈Çƒôd√≥w, dokumentacja parametru --main-audio

## ‚úÖ Definicja Uko≈Ñczenia (DoD)

Projekt jest uko≈Ñczony gdy:
- [ ] Wszystkie testy przechodzƒÖ (100%)
- [ ] Pokrycie test√≥w > 90%
- [ ] CLI dzia≈Ça zgodnie ze specyfikacjƒÖ
- [ ] Dokumentacja jest kompletna
- [ ] Kod przeszed≈Ç review
- [ ] Wydajno≈õƒá w akceptowalnych granicach
- [ ] Brak znanych bug√≥w krytycznych

## üîÑ Proces Iteracyjny

Po ka≈ºdej fazie:
1. **Uruchomienie test√≥w** - sprawdzenie czy nic siƒô nie zepsu≈Ço
2. **Code review** - sprawdzenie jako≈õci kodu
3. **Dokumentacja** - aktualizacja dokumentacji
4. **Commit** - atomic commit z opisem zmian
5. **Demo** - prezentacja postƒôpu

## üõ†Ô∏è Narzƒôdzia i ≈örodowisko

### Wymagane Narzƒôdzia:
- **Python 3.9+** z uv
- **Blender 4.0+** w PATH
- **FFmpeg 4.4+** w PATH
- **pytest** do test√≥w
- **Git** do kontroli wersji

### ≈örodowisko Deweloperskie:
```bash
# Przygotowanie ≈õrodowiska
uv sync
uv run pytest  # sprawdzenie test√≥w
which blender  # sprawdzenie Blender
which ffmpeg   # sprawdzenie FFmpeg
```

### Komendy Deweloperskie:
```bash
# Uruchomienie test√≥w
uv run pytest tests/test_blender_project.py -v

# Test CLI
uv run python -m cli.blend_setup ./test_recording --verbose

# Sprawdzenie pokrycia test√≥w
uv run pytest --cov=src --cov-report=html
``` 